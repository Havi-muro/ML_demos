
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Perceptron — Random Sampling, Learn Weights and Bias</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #0f172a;
    --panel: #0b1220;
    --accent: #22c55e;
    --accent2: #3b82f6;
    --accent3: #f59e0b;
    --text: #e5e7eb;
    --muted: #9ca3af;
    --danger: #ef4444;
  }
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Ubuntu, Cantarell, "Noto Sans";
    background: linear-gradient(135deg, #0b1024 0%, #0f172a 100%);
    color: var(--text);
  }
  header {
    padding: 20px 24px;
    border-bottom: 1px solid #1f2937;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  header h1 { margin: 0; font-size: 20px; font-weight: 700; }

  .intro {
    margin: 16px 20px 0;
    background: #0b1024;
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 14px 16px;
    line-height: 1.55;
    color: #cbd5e1;
  }
  .intro strong { color: #e2e8f0; }
  .intro code { color: #c7f9cc; }

  .container {
    display: grid;
    grid-template-columns: 1.2fr 1fr;
    gap: 20px;
    padding: 20px;
  }
  .panel {
    background: var(--panel);
    border: 1px solid #1f2937;
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
  }
  .panel h2 { margin: 0 0 12px; font-size: 16px; font-weight: 700; }

  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 12px;
  }
  .control { display: flex; flex-direction: column; gap: 6px; }
  .control label { font-size: 13px; color: var(--muted); }
  .control input[type="number"] {
    background: #0b1024;
    border: 1px solid #1f2937;
    color: var(--text);
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 14px;
  }
  .buttons { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; }
  button {
    appearance: none;
    border: 1px solid #1f2937;
    background: #0b1024;
    color: var(--text);
    padding: 10px 12px;
    border-radius: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 150ms ease;
  }
  button:hover { transform: translateY(-1px); }
  #runBtn { border-color: var(--accent); color: #10b981; }
  #resetBtn { border-color: var(--danger); color: #f87171; }
  #randomBtn { border-color: var(--accent2); color: #60a5fa; }

  .status { font-size: 13px; color: var(--muted); line-height: 1.5; }
  .metrics {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 8px;
  }
  .metric { background: #0b1024; border: 1px solid #1f2937; border-radius: 10px; padding: 10px; }
  .metric code {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace;
    font-size: 13px;
  }

  canvas {
    width: 100%;
    height: 520px;
    background: radial-gradient(ellipse at center, #0b1220 0%, #0a0e1a 60%, #090d18 100%);
    border: 1px solid #1f2937;
    border-radius: 12px;
  }
  .legend { display: flex; gap: 14px; align-items: center; margin-top: 8px; font-size: 13px; color: var(--muted); }
  .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; margin-right: 6px; }
  .dot.blue { background: var(--accent2); }
  .dot.orange { background: var(--accent3); }
  .dot.white { background: #e5e7eb; }

  #epochLog {
    max-height: 220px; overflow-y: auto; border: 1px solid #1f2937; padding: 8px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    background: #0b1024; width: 100%; border-radius: 8px;
    margin-top: 10px;
  }
  .logline { white-space: pre; margin: 2px 0; }
  .muted { color: #94a3b8; }

  @media (max-width: 960px) { .container { grid-template-columns: 1fr; } canvas { height: 400px; } }
</style>
</head>
<body>
  <header>
    <h1>Perceptron — Random Sampling (Learn Weights & Bias)</h1>
    <div style="font-size:13px;color:#94a3b8;">Sampling is <strong>random</strong> each step. Updates occur <em>only</em> on mistakes.</div>
  </header>

  <div class="intro">
    <strong>Update rule (labels ±1):</strong>
    <code>w ← w + η · y · x</code>, <code>b ← b + η_b · y</code> &nbsp;(applied only if misclassified).
    <ul style="margin: 6px 0 0 18px;">
      <li>False negative (pred −1, true +1) → add features and increase bias.</li>
      <li>False positive (pred +1, true −1) → subtract features and decrease bias.</li>
      <li>Correct classification → <strong>no update</strong>.</li>
    </ul>
    <div style="margin-top:6px;color:#9ca3af;">
      Epoch = <em>N random steps</em>, where N is the number of samples. A summary (Δw, Δb, mistakes) is logged each epoch.
    </div>
  </div>

  <div class="container">
    <!-- LEFT: Chart -->
    <div class="panel">
      <h2>Dataset & Decision Boundary</h2>
      <canvas id="plot" width="900" height="520"></canvas>
      <div class="legend">
        <span><span class="dot blue"></span>Class +1 (blue)</span>
        <span><span class="dot orange"></span>Class −1 (orange)</span>
        <span><span class="dot white"></span>Currently sampled point</span>
      </div>
      <div class="note" style="margin-top:10px;color:#94a3b8;font-size:12px;">
        Decision boundary: <code>w_x · x + w_y · y + b = 0</code>.
      </div>
    </div>

    <!-- RIGHT: Controls & Status -->
    <div class="panel">
      <h2>Controls</h2>
      <div class="controls">
        <div class="control">
          <label for="lr">Learning rate (η) for weights</label>
          <input id="lr" type="number" step="0.01" value="0.2" />
        </div>
        <div class="control">
          <label for="lrB">Bias learning rate (η_b)</label>
          <input id="lrB" type="number" step="0.01" value="1.0" />
        </div>
        <div class="control">
          <label for="maxEpochs">Max epochs (Run)</label>
          <input id="maxEpochs" type="number" step="1" value="50" />
        </div>
        <div class="control">
          <label for="delay">Run delay per step (ms)</label>
          <input id="delay" type="number" step="10" value="30" />
        </div>
      </div>

      <div class="buttons">
        <button id="stepBtn">Step</button>
        <button id="runBtn">Run</button>
        <button id="resetBtn">Reset</button>
        <button id="randomBtn">Randomize data</button>
      </div>

      <div class="status" id="status">
        Ready. Initial <code>w = (0.00, 0.00)</code>, <code>b = 0.00</code>. Sampling: <strong>random</strong>.
      </div>

      <div class="metrics">
        <div class="metric">
          <div><strong>Weights & Bias</strong></div>
          <div id="weights"><code>w = (0.00, 0.00)</code></div>
          <div id="bias"><code>b = 0.00</code></div>
          <div id="norm"><code>‖w‖ = 0.00</code></div>
        </div>
        <div class="metric">
          <div><strong>Accuracy</strong></div>
          <div id="acc"><code>Accuracy = 0.00%</code></div>
          <div id="mis"><code>Misclassified = 0 / 0</code></div>
        </div>
      </div>

      <h3 style="margin-top:16px;">Epoch summaries</h3>
      <div id="epochLog" aria-live="polite" aria-label="Epoch update summaries"></div>
    </div>
  </div>

  <script>
    // ============================
    // CONFIG & STATE
    // ============================
    const canvas = document.getElementById('plot');
    const ctx = canvas.getContext('2d');

    const stepBtn = document.getElementById('stepBtn');
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');
    const randomBtn = document.getElementById('randomBtn');

    const lrInput = document.getElementById('lr');
    const lrBInput = document.getElementById('lrB');
    const maxEpochsInput = document.getElementById('maxEpochs');
    const delayInput = document.getElementById('delay');

    const statusEl = document.getElementById('status');
    const weightsEl = document.getElementById('weights');
    const biasEl = document.getElementById('bias');
    const normEl = document.getElementById('norm');
    const accEl = document.getElementById('acc');
    const misEl = document.getElementById('mis');
    const epochLog = document.getElementById('epochLog');

    const RANGE = { xmin: 0, xmax: 10, ymin: 0, ymax: 10 };

    const COLOR_PLUS = '#3b82f6';   // blue
    const COLOR_MINUS = '#f59e0b';  // orange
    const COLOR_AXIS = '#374151';
    const COLOR_GRID = '#1f2937';
    const COLOR_BOUNDARY = '#22c55e';
    const COLOR_ACTIVE = '#e5e7eb';

    let data = []; // {x,y,label}
    let w = { x: 0, y: 0 };
    let b = 0;

    // For random sampling, we store the most recent sampled index for highlighting
    let currentIndex = -1;

    // Epoch accounting: define an epoch as N random steps
    let epoch = 0;
    let stepsInEpoch = 0;

    // per-epoch accumulators
    let epochDelta = resetEpochDelta();

    function resetEpochDelta() {
      return { dw: [0, 0], db: 0, mistakes: 0 };
    }

    // ============================
    // UTILITIES
    // ============================
    const mapX = (x) => {
      const pad = 40;
      return pad + (x - RANGE.xmin) * (canvas.width - 2 * pad) / (RANGE.xmax - RANGE.xmin);
    };
    const mapY = (y) => {
      const pad = 30;
      const v = pad + (y - RANGE.ymin) * (canvas.height - 2 * pad) / (RANGE.ymax - RANGE.ymin);
      return canvas.height - v; // invert y for canvas
    };
    const unmapX = (px) => {
      const pad = 40;
      return RANGE.xmin + (px - pad) * (RANGE.xmax - RANGE.xmin) / (canvas.width - 2 * pad);
    };
    const unmapY = (py) => {
      const pad = 30;
      const v = canvas.height - py;
      return RANGE.ymin + (v - pad) * (RANGE.ymax - RANGE.ymin) / (canvas.height - 2 * pad);
    };

    function dot(wx, wy, x, y, bias) { return wx * x + wy * y + bias; }
    function length(vec) { return Math.sqrt(vec.x * vec.x + vec.y * vec.y); }

    function signScore(s) {
      if (s > 0) return +1;
      if (s < 0) return -1;
      return 0; // treat boundary as 0 (we will handle as misclassified)
    }

    function pickRandomIndex(n) {
      return Math.floor(Math.random() * n);
    }

    // ============================
    // DATA: separable upper-right quadrant
    // ============================
    function makeDefaultData() {
      const pts = [];
      const randn = () => {
        // Box-Muller
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
      };
      const randu = (a, b) => a + Math.random() * (b - a);

      const N = 24;             // points per class
      const slopeMinus = 0.95;  // lower slope (class -1)
      const slopePlus  = 1.15;  // higher slope (class +1)
      const noiseScale = 0.15;  // small vertical noise
      const xJitter    = 0.10;  // small x jitter
      const xMin = 1.5, xMax = 9.5;

      const clipNoise = (n) => Math.max(-0.14, Math.min(0.14, n));

      for (let i = 0; i < N; i++) {
        const baseX = randu(xMin, xMax);
        const x1 = Math.max(0.05, baseX + xJitter * randn());
        const x2 = Math.max(0.05, baseX + xJitter * randn());

        const yPlus  = slopePlus  * baseX + clipNoise(noiseScale * randn());
        const yMinus = slopeMinus * baseX + clipNoise(noiseScale * randn());

        pts.push({ x: x1, y: Math.max(0.05, yPlus),  label: +1 });
        pts.push({ x: x2, y: Math.max(0.05, yMinus), label: -1 });
      }
      return pts;
    }

    function randomizeData() {
      data = makeDefaultData();
      currentIndex = -1;
      epoch = 0;
      stepsInEpoch = 0;
      epochDelta = resetEpochDelta();
      epochLog.innerHTML = '';
      statusEl.innerHTML = `Dataset randomized (linearly separable). Sampling: <strong>random</strong>.`;
      draw();
      updateMetrics();
    }

    // ============================
    // DRAWING
    // ============================
    function drawAxes() {
      // Grid
      ctx.strokeStyle = COLOR_GRID;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let gx = Math.ceil(RANGE.xmin); gx <= RANGE.xmax; gx += 1) {
        ctx.moveTo(mapX(gx), mapY(RANGE.ymin));
        ctx.lineTo(mapX(gx), mapY(RANGE.ymax));
      }
      for (let gy = Math.ceil(RANGE.ymin); gy <= RANGE.ymax; gy += 1) {
        ctx.moveTo(mapX(RANGE.xmin), mapY(gy));
        ctx.lineTo(mapX(RANGE.xmax), mapY(gy));
      }
      ctx.stroke();

      // Axes
      ctx.strokeStyle = COLOR_AXIS;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(mapX(RANGE.xmin), mapY(0));
      ctx.lineTo(mapX(RANGE.xmax), mapY(0));
      ctx.moveTo(mapX(0), mapY(RANGE.ymin));
      ctx.lineTo(mapX(0), mapY(RANGE.ymax));
      ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui';
      ctx.fillText('x', mapX(RANGE.xmax) - 16, mapY(0) - 8);
      ctx.fillText('y', mapX(0) + 8, mapY(RANGE.ymax) + 16);
    }

    function drawPoints() {
      for (let i = 0; i < data.length; i++) {
        const pt = data[i];
        const px = mapX(pt.x);
        const py = mapY(pt.y);
        const color = pt.label === +1 ? COLOR_PLUS : COLOR_MINUS;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, 2 * Math.PI);
        ctx.fill();

        if (i === currentIndex) {
          ctx.strokeStyle = COLOR_ACTIVE;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(px, py, 9, 0, 2 * Math.PI);
          ctx.stroke();
        }
      }
    }

    function drawWeightsVector() {
      if (length(w) < 1e-6) return;
      const originX = mapX(0), originY = mapY(0);
      const scale = 12;
      const endX = mapX(w.x / scale);
      const endY = mapY(w.y / scale);

      ctx.strokeStyle = '#a7f3d0';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(originX, originY);
      ctx.lineTo(endX, endY);
      ctx.stroke();

      const angle = Math.atan2(originY - endY, endX - originX);
      const headLen = 10;
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - headLen * Math.cos(angle - Math.PI / 6),
                 endY + headLen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(endX - headLen * Math.cos(angle + Math.PI / 6),
                 endY + headLen * Math.sin(angle + Math.PI / 6));
      ctx.lineTo(endX, endY);
      ctx.fillStyle = '#a7f3d0';
      ctx.fill();
    }

    function drawDecisionBoundary() {
      const wx = w.x, wy = w.y, bias = b;
      if (Math.abs(wx) < 1e-9 && Math.abs(wy) < 1e-9) return;

      ctx.strokeStyle = COLOR_BOUNDARY;
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      ctx.beginPath();

      if (Math.abs(wy) >= 1e-9) {
        const x1 = RANGE.xmin, x2 = RANGE.xmax;
        const y1 = - (wx / wy) * x1 - (bias / wy);
        const y2 = - (wx / wy) * x2 - (bias / wy);
        ctx.moveTo(mapX(x1), mapY(y1));
        ctx.lineTo(mapX(x2), mapY(y2));
      } else {
        const xv = -bias / wx;
        ctx.moveTo(mapX(xv), mapY(RANGE.ymin));
        ctx.lineTo(mapX(xv), mapY(RANGE.ymax));
      }

      ctx.stroke();
      ctx.setLineDash([]);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawAxes();
      drawDecisionBoundary();
      drawWeightsVector();
      drawPoints();
    }

    // ============================
    // METRICS & STATUS
    // ============================
    function classify(pt) {
      const s = dot(w.x, w.y, pt.x, pt.y, b);
      const pred = signScore(s);
      return pred;
    }

    function recomputeAccuracy() {
      let correct = 0, mis = 0;
      for (const pt of data) {
        const pred = classify(pt);
        if (pred === pt.label) correct++;
        else mis++;
      }
      return { correct, mis, total: data.length, acc: data.length ? (correct / data.length) * 100 : 0 };
    }

    function updateMetrics() {
      const { correct, mis, total, acc } = recomputeAccuracy();
      weightsEl.innerHTML = `<code>w = (${w.x.toFixed(2)}, ${w.y.toFixed(2)})</code>`;
      biasEl.innerHTML = `<code>b = ${b.toFixed(2)}</code>`;
      normEl.innerHTML = `<code>‖w‖ = ${length(w).toFixed(2)}</code>`;
      accEl.innerHTML = `<code>Accuracy = ${acc.toFixed(2)}%</code>`;
      misEl.innerHTML = `<code>Misclassified = ${mis} / ${total}</code>`;
    }

    function logEpochSummary(epochNum, summary) {
      const line = document.createElement('div');
      line.className = 'logline';
      line.textContent =
        `Epoch ${epochNum.toString().padStart(3, ' ')}: ` +
        `Δw=[${summary.dw[0].toFixed(3)}, ${summary.dw[1].toFixed(3)}], ` +
        `Δb=${summary.db.toFixed(3)}, mistakes=${summary.mistakes}`;
      epochLog.insertAdjacentElement('afterbegin', line);

      while (epochLog.children.length > 80) epochLog.lastChild.remove();
    }

    // ============================
    // TRAINING (Random Sampling)
    // ============================
    function stepOnce() {
      if (!data.length) return;

      const eta  = parseFloat(lrInput.value);
      const etaB = parseFloat(lrBInput.value);
      if (!isFinite(eta) || eta <= 0) {
        statusEl.innerHTML = `<span style="color:#f87171">Invalid η. Use a positive number (e.g., 0.2).</span>`;
        return;
      }
      if (!isFinite(etaB) || etaB <= 0) {
        statusEl.innerHTML = `<span style="color:#f87171">Invalid η_b. Use a positive number (e.g., 1.0).</span>`;
        return;
      }

      // --- RANDOMLY PICK A SAMPLE EACH STEP ---
      currentIndex = pickRandomIndex(data.length);
      const pt = data[currentIndex];
      const y = pt.label;

      const s = dot(w.x, w.y, pt.x, pt.y, b);
      const pred = signScore(s === 0 ? -y : s); // treat exactly-on-boundary as misclassified (push away)
      // (the s===0?-y: s trick biases the tie against current point to keep updates moving)

      if (pred !== y) {
        // Misclassified → update weights and bias
        const dw0 = eta * y * pt.x;
        const dw1 = eta * y * pt.y;
        const db  = etaB * y;

        w.x += dw0;
        w.y += dw1;
        b   += db;

        epochDelta.dw[0] += dw0;
        epochDelta.dw[1] += dw1;
        epochDelta.db    += db;
        epochDelta.mistakes += 1;

        const dir = (y > 0) ? 'add' : 'subtract';
        statusEl.innerHTML =
          `Misclassified → ${dir} input features and ${dir} bias: ` +
          `<code>Δw = [${dw0.toFixed(2)}, ${dw1.toFixed(2)}], Δb = ${db.toFixed(2)}</code>`;
      } else {
        statusEl.innerHTML = `Correct → no update (<code>Δw = [0, 0], Δb = 0</code>).`;
      }

      // Epoch accounting: N random steps per epoch
      stepsInEpoch++;
      if (stepsInEpoch >= data.length) {
        logEpochSummary(epoch, epochDelta);
        const { mis } = recomputeAccuracy();
        if (mis === 0) {
          const note = document.createElement('div');
          note.className = 'logline muted';
          note.textContent = `No mistakes in epoch ${epoch} → converged.`;
          epochLog.insertAdjacentElement('afterbegin', note);
        }
        epoch++;
        stepsInEpoch = 0;
        epochDelta = resetEpochDelta();
      }

      draw();
      updateMetrics();
    }

    async function runLoop() {
      if (!data.length) return;
      let running = (runBtn.dataset.running === 'true') ? true : false;
      running = !running;
      runBtn.dataset.running = running ? 'true' : 'false';
      runBtn.textContent = running ? 'Stop' : 'Run';

      const maxEpochs = parseInt(maxEpochsInput.value) || 50;
      const delay = Math.max(0, parseInt(delayInput.value) || 0);
      const startEpoch = epoch;

      while (running) {
        stepOnce();
        await sleep(delay);

        const { mis } = recomputeAccuracy();
        if (mis === 0) {
          statusEl.innerHTML = `Converged: 0 misclassifications.`;
          running = false;
          runBtn.dataset.running = 'false';
          runBtn.textContent = 'Run';
          break;
        }

        if ((epoch - startEpoch) >= maxEpochs) {
          const note = document.createElement('div');
          note.className = 'logline muted';
          note.textContent = `Stopped after ${maxEpochs} epochs.`;
          epochLog.insertAdjacentElement('afterbegin', note);
          running = false;
          runBtn.dataset.running = 'false';
          runBtn.textContent = 'Run';
          break;
        }
      }
    }

    // ============================
    // INTERACTION
    // ============================
    stepBtn.addEventListener('click', stepOnce);
    runBtn.addEventListener('click', runLoop);
    resetBtn.addEventListener('click', () => {
      w = { x: 0, y: 0 };
      b = 0;
      currentIndex = -1;
      epoch = 0;
      stepsInEpoch = 0;
      runBtn.dataset.running = 'false';
      runBtn.textContent = 'Run';
      epochDelta = resetEpochDelta();
      epochLog.innerHTML = '';
      statusEl.innerHTML = `Reset: <code>w = (0.00, 0.00)</code>, <code>b = 0.00</code>. Sampling: <strong>random</strong>.`;
      draw();
      updateMetrics();
    });
    randomBtn.addEventListener('click', randomizeData);

    // Add points by clicking: label via a separator slope between the two class slopes
    canvas.addEventListener('click', (evt) => {
      const rect = canvas.getBoundingClientRect();
      const px = evt.clientX - rect.left;
      const py = evt.clientY - rect.top;
      const x = Math.max(0.05, unmapX(px));
      const yv = Math.max(0.05, unmapY(py));
      const sepSlope = 1.05; // between 0.95 and 1.15
      const lbl = (yv > sepSlope * x) ? +1 : -1;
      data.push({ x, y: yv, label: lbl });
      statusEl.innerHTML = `Added point (${x.toFixed(2)}, ${yv.toFixed(2)}) with label ${lbl > 0 ? '+1' : '-1'}.`;
      draw();
      updateMetrics();
    });

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // ============================
    // INIT
    // ============================
    (function init() {
      data = makeDefaultData();
      w = { x: 0, y: 0 };
      b = 0;
      currentIndex = -1;
      epoch = 0;
      stepsInEpoch = 0;
      epochDelta = resetEpochDelta();
      draw();
      updateMetrics();
    })();
  </script>
</body>
</html>
